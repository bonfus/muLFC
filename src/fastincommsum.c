/**
 * @file fastincommsum.c
 * @author Pietro Bonfa
 * @date 9 Sep 2016
 * @brief Dipolar field calculator.
 *     
 */

#define _USE_MATH_DEFINES
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "mat3.h"
#include "pile.h"
#include "config.h"

#ifndef M_PI
#    define M_PI 3.14159265358979323846
#endif

#ifdef _OPENMP
#include <omp.h>
#endif 


/**
 * This function calculates the dipolar field for helical structures
 * 
 * @param in_positions positions of the magnetic atoms in fractional 
 *         coordinates. Each position is specified by the three
 *         coordinates and the 1D array must be 3*in_natoms long.
 * @param in_fc Fourier components. For each atom in in_positions 6 numbers must be specified.
 *              The standard input is Re(FC_x) Im(FC_x) Re(FC_y) Im(FC_y) Re(FC_z) Im(FC_z)
 *              (the input format can be changed by defining the 
 *              _ALTERNATE_FC_INPUT at compile time, but this is highly discouraged).
 *              These values must be provided in the Cartesian coordinate system
 *              defined by in_cell.
 * @param in_K the propagation vector in reciprocal lattice units.
 * @param in_phi the phase for each of the atoms given in in_positions.
 * @param in_muonpos position of the muon in fractional coordinates
 * @param in_supercell extension of the supercell along the lattice vectors.
 * @param in_cell lattice cell. The three lattice vectors should be entered 
 *         with the following order: a_x, a_y, a_z, b_z, b_y, b_z, c_x, c_y, c_z.
 * @param radius Lorentz sphere radius
 * @param nnn_for_cont number of nearest neighboring atoms to be included
 *                      for the evaluation of the contact field.
 * @param cont_radius only atoms within this radius are eligible to contribute to
 *                      the contact field. This option is redundant but speeds
 *                      up the evaluation significantly
 * @param in_natoms: number of atoms in the lattice.
 * @param in_nangles: number of angles used to sample the field distribution 
 *                      generated by an incommensurate order
 * @param out_field_cont Contact filed in Cartesian coordinates defined by in_cell.
 * @param out_field_dip  Dipolar field in Cartesian coordinates defined by in_cell.
 * @param out_field_lor  Lorentz field in Cartesian coordinates defined by in_cell.
 */
void FastIncommSum(const double *in_positions, 
          const double *in_fc, const double *in_K, const double *in_phi,
          const double *in_muonpos, const int * in_supercell, const double *in_cell, 
          const double radius, const unsigned int nnn_for_cont, const double cont_radius, 
          unsigned int in_natoms, unsigned int in_nangles,
          double *out_field_cont, double *out_field_dip, double *out_field_lor) 
{

    unsigned int scx, scy, scz = 10; //supercell sizes
    unsigned int i,j,k; // counters for supercells
    
    vec3 * atmpos;
    vec3 * muonpos;

    vec3 * r;
    vec3 * u;   // unit vector

    mat3 * sc_lat;
    mat3 * inv_sc_lat;
    
    double n;
    double c,s; //cosine and sine of K.R
    double onebrcube; // 1/r^3
    
    double  phi ;
    
    // tmp value for speed and clearness
    
    double * stagmom;                    // this is m_0
    vec3 ** refatmpos;             // reference atom used to produce C and S    
    vec3 ** Ahelix, **Bhelix; // two unit vectors describing the helix in the m_0 (cos(phi).a +/- sin(phi).b)
    vec3 ** SDip, ** CDip; // sums of contribution providing cosine and sine prefactors
    vec3 ** SLor, **CLor; // sums of contribution providing cosine and sine prefactors
    
    pile CCont, SCont;
    
    vec3 * K;
    

    unsigned int a, angn;     // counter for atoms

    // initialize variables
    vec3 * tmp = new_vec3_zero();
    atmpos = new_vec3_zero();
    r = new_vec3_zero();
    
    pile_init(&CCont, nnn_for_cont);
    pile_init(&SCont, nnn_for_cont);
    
    stagmom = malloc(in_natoms*sizeof(scalar));  refatmpos = malloc(in_natoms*sizeof(vec3*));
    Ahelix = malloc(in_natoms*sizeof(vec3*));    Bhelix = malloc(in_natoms*sizeof(vec3*));
    SDip = malloc(in_natoms*sizeof(vec3*));      CDip = malloc(in_natoms*sizeof(vec3*));
    SLor = malloc(in_natoms*sizeof(vec3*));      CLor = malloc(in_natoms*sizeof(vec3*));
    
    
    for (a = 0; a < in_natoms; ++a)
    {
        Ahelix[a] = new_vec3_zero();
        Bhelix[a] = new_vec3_zero();
        CDip[a]   = new_vec3_zero();
        SDip[a]   = new_vec3_zero();
        CLor[a]   = new_vec3_zero();
        SLor[a]   = new_vec3_zero();
    }
    
    // define dupercell size
    scx = in_supercell[0];
    scy = in_supercell[1];
    scz = in_supercell[2];

#ifdef _DEBUG    
    printf("I use: %i %i %i\n",scx, scy, scz);    
    printf("Size is: %i\n",size);
#endif 
    
    sc_lat = new_mat3(in_cell[0], in_cell[1], in_cell[2],
                      in_cell[3], in_cell[4], in_cell[5],
                      in_cell[6], in_cell[7], in_cell[8]);

    inv_sc_lat = new_mat3_zero();
    mat3_inv(sc_lat, inv_sc_lat);

#ifdef _DEBUG      
    for (i=0;i<3;i++)
        printf("Cell is: %i %e %e %e\n",i,in_cell[i*3],in_cell[i*3+1],in_cell[i*3+2]);
      
    printf("Inverse cell is %e %e %e\n", inv_sc_lat.a.x, inv_sc_lat.a.y, inv_sc_lat.a.z);
    printf("Inverse cell is %e %e %e\n", inv_sc_lat.b.x, inv_sc_lat.b.y, inv_sc_lat.b.z);
    printf("Inverse cell is %e %e %e\n", inv_sc_lat.c.x, inv_sc_lat.c.y, inv_sc_lat.c.z);

    for (a = 0; a < in_natoms; ++a)
    {
                    
        // atom position in reduced coordinates
        atmpos.x =  in_positions[3*a] ;
        atmpos.y =  in_positions[3*a+1] ;
        atmpos.z =  in_positions[3*a+2] ;
        
        printf("Atom pos (crys): %e %e %e\n",atmpos.x,atmpos.y,atmpos.z);
        
        // go to cartesian coordinates (in Angstrom!)
        atmpos = mat3_vmul(atmpos,sc_lat);  
        
        printf("Atom pos (cart): %e %e %e\n",atmpos.x,atmpos.y,atmpos.z);
#ifdef _ALTERNATE_FC_INPUT
        printf("FC (real, imag): %e %e %e %e %e %e\n",in_fc[6*a],in_fc[6*a+1],in_fc[6*a+2],in_fc[6*a+3],in_fc[6*a+4],in_fc[6*a+5]);
#else
        printf("FC (real, imag): %e %e %e %e %e %e\n",in_fc[6*a],in_fc[6*a+2],in_fc[6*a+4],in_fc[6*a+1],in_fc[6*a+3],in_fc[6*a+5]);
#endif
        printf("phi: %e\n",in_phi[a]);
    }
        

#endif     
    
    K = new_vec3( in_K[0], in_K[1], in_K[2]);

#ifdef _DEBUG     
    printf("K is: %e %e %e \n",K.x,K.y,K.z);
    printf("Radius is: %e\n",radius);
#endif

    mat3* sctmp = new_mat3_diag((double) scx, (double) scy, (double) scz);
    mat3_mul(sctmp,sc_lat, sc_lat);
    mat3_free(sctmp);
    
    
    // muon position in reduced coordinates
    muonpos = new_vec3(    (in_muonpos[0] + (scx/2) ) / (double) scx,
                        (in_muonpos[1] + (scy/2) ) / (double) scy,
                        (in_muonpos[2] + (scz/2) ) / (double) scz);
    
    

#ifdef _DEBUG
    printf("Muon pos (frac): %e %e %e\n",muonpos->x,muonpos->y,muonpos->z);
#endif

    mat3_vmul(muonpos,sc_lat,muonpos);

#ifdef _DEBUG
    printf("Muon pos (cart): %e %e %e\n",muonpos.x,muonpos.y,muonpos.z);
#endif


    
    for (a = 0; a < in_natoms; ++a)
    {
        // reference atom in reduced coordinates
        //   the first atom is chosen as reference
        refatmpos[a] = new_vec3( (in_positions[3*a+0] + (scx/2) ) / (float) scx,
                                 (in_positions[3*a+1] + (scy/2) ) / (float) scy,
                                 (in_positions[3*a+2] + (scz/2) ) / (float) scz);


#ifdef _DEBUG
        printf("Reference atom pos (frac): %e %e %e\n",refatmpos[a].x,refatmpos[a].y,refatmpos[a].z);
#endif

        mat3_vmul(refatmpos[a], sc_lat, refatmpos[a]);

#ifdef _DEBUG
        printf("Reference atom pos (cart): %e %e %e\n",refatmpos[a].x,refatmpos[a].y,refatmpos[a].z);
#endif

        
        
        // now take care of magntism
        
#ifdef _ALTERNATE_FC_INPUT
        printf("ERROR!!! If you see this in the Python extension something went wrong!\n");
        vec3_set(tmp, in_fc[6*a],
                      in_fc[6*a+1], 
                      in_fc[6*a+2]);
#else
        vec3_set(tmp, in_fc[6*a],
                      in_fc[6*a+2],
                      in_fc[6*a+4]);
#endif
        stagmom[a] = vec3_norm(tmp);
        vec3_muls(1.0/stagmom[a], tmp);
        vec3_cpy(Ahelix[a], tmp);
        
        // now B
#ifdef _ALTERNATE_FC_INPUT
        printf("ERROR!!! If you see this in the Python extension something went wrong!\n");
        vec3_set(tmp, in_fc[6*a+3],
                      in_fc[6*a+4], 
                      in_fc[6*a+5]);
#else
        vec3_set(tmp, in_fc[6*a+1], 
                      in_fc[6*a+3], 
                      in_fc[6*a+5]);
#endif      
        // check if they are the same
        if (fabs(stagmom[a] - vec3_norm(tmp))>EPS)
        {
            printf("ERROR!!! Staggered moment is different in real and imag parts of atom %u\n Use another routine!\n",a);
        }
        vec3_muls(1.0/vec3_norm(tmp),tmp);
        vec3_cpy(Bhelix[a], tmp);
        
        if (fabs(vec3_dot(Ahelix[a],Bhelix[a])) > EPS)
        {
            printf("ERROR!!! Real and imaginary part of atom %u are not orthogonal by %e!\n",a,vec3_dot(Ahelix[a],Bhelix[a]));
        }

#ifdef _DEBUG
        printf("Unit vector a (cart): %e %e %e\n",Ahelix[a].x,Ahelix[a].y,Ahelix[a].z);
        printf("Unit vector b (cart): %e %e %e\n",Bhelix[a].x,Bhelix[a].y,Bhelix[a].z);
        printf("Stag mom: %e\n", stagmom[a]);
#endif        
        
        if (fabs(in_phi[a]) > EPS)
        {
            printf("WARNING!!! Phi not completely tested! Double check your results.\n");
        }
        
    }
    

// parallel execution starts here
// the shared variables are listed just to remember about data races!
// other variable shaed by default: refatmpos,atmpos,phi,Ahelix,Bhelix
#pragma omp parallel shared(SDip,CDip,SLor,CLor,SCont,CCont,scx,scy,scz,in_positions) 
{
#pragma omp for collapse(3) private(i,j,k,a,r,n,c,s,u,crysvec,onebrcube,atmpos)
    for (i = 0; i < scx; ++i)
    {
        for (j = 0; j < scy; ++j)
        {
            for (k = 0; k < scz; ++k)
            {
                // loop over atoms
                for (a = 0; a < in_natoms; ++a)
                {
                    
                    // atom position in reduced coordinates
                    vec3_set(atmpos, ( in_positions[3*a] + (double) i) / (double) scx,
                                     ( in_positions[3*a+1] + (double) j) / (double) scy,
                                     ( in_positions[3*a+2] + (double) k) / (double) scz);
                    
                    
                    
                    // go to cartesian coordinates (in Angstrom!)
                    mat3_vmul(atmpos, sc_lat, atmpos);
                    
                    //printf("atompos: %e %e %e\n", atmpos->x, atmpos->y, atmpos->z);
                    // difference between atom pos and muon pos (cart coordinates)
                    
                    vec3_cpy(r,atmpos);
                    vec3_sub(r,muonpos); // should be the opposite, but -1 below    (*)
                    
                    n = vec3_norm(r);
                    if (n < radius)
                    {

                        phi = in_phi[a];

                        // go back to fractional (crystal) definition!
                        // !!!!! CHECK THIS DEFINITION !!!!
                        vec3_cpy(tmp,r);
                        vec3_sub(tmp,refatmpos[a]);
                        //vec3_muls(-1.,tmp);
                        mat3_vmul(tmp,inv_sc_lat,tmp); // now in crystal coord
                        //printf("crysvec : %e %e %e\n", tmp->x, tmp->y,tmp->z);
                        //
                        c = cos ( 2.0*M_PI * (vec3_dot(K,tmp) + phi ) );
                        s = sin ( 2.0*M_PI * (vec3_dot(K,tmp) + phi ) );

                        // unit vector
                        vec3_muls(-1.0/n,r);                                      // (*)
                        u = r;
                        onebrcube = 1.0/pow(n,3);
                        

#ifdef _DEBUG
                        printf("crysvec : %e %e %e\n", crysvec->x, crysvec->y,crysvec->z);
                        vec3_cpy(tmp, atmpos);
                        tmp = vec3_sub(tmp,muonpos);
                        printf("vec3_sub(atmpos,muonpos) : %e %e %e\n", tmp->x, tmp->y,tmp->z);
                        tmp = vec3_sub(vec3_sub(atmpos,muonpos),refatmpos[a]);
                        printf("vec3_sub(vec3_sub(atmpos,muonpos),refatmpos[a]) : %e %e %e\n",  tmp.x, tmp.y,tmp.z);
                        
                        printf("vec3_dot(K,vec3_sub(vec3_sub(atmpos,muonpos),refatmpos[a])) : %e \n",  vec3_dot(K,vec3_sub(vec3_sub(atmpos,muonpos),refatmpos[a])));
                        
                        
                        printf("cos is this time : %e \n", c);
                        printf("sin is this time : %e \n", s);

                        
                        printf("u is : %e %e %e\n", u.x, u.y, u.z);
                        tmp = vec3_muls(onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Ahelix[a],u),u), Ahelix[a]));
                        printf("A part %d is : %e %e %e\n", a, tmp.x, tmp.y, tmp.z);
                        tmp = vec3_muls(onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Bhelix[a],u),u), Bhelix[a]));
                        printf("B part %d is : %e %e %e\n", a, tmp.x, tmp.y, tmp.z);
                        
                        tmp = vec3_add (
                                            vec3_muls( c * onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Ahelix[a],u),u), Ahelix[a])),
                                            vec3_muls( s * onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Bhelix[a],u),u), Bhelix[a]))
                                       );
                                       
                        printf("CDip %d to be added : %e %e %e\n", a, tmp.x, tmp.y, tmp.z);
                        tmp =  vec3_sub(
                                            vec3_muls( s * onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Ahelix[a],u),u), Ahelix[a])),
                                            vec3_muls( c * onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Bhelix[a],u),u), Bhelix[a]))
                                        );
                        printf("SDip %d to be added : %e %e %e\n", a, tmp.x, tmp.y, tmp.z);
#endif
                        // sum all data
                        #pragma omp critical(dipolar)
                        {
                            // Dipolar
                            vec3_cpy(tmp, u);
                            vec3_muls(3.0*vec3_dot(Ahelix[a],tmp),tmp);
                            vec3_sub(tmp, Ahelix[a]);
                            vec3_muls( c * onebrcube , tmp);
                            vec3_add(CDip[a], tmp);
                            

                            
                            vec3_cpy(tmp, u);
                            vec3_muls(3.0*vec3_dot(Bhelix[a],tmp),tmp);
                            vec3_sub(tmp, Bhelix[a]);
                            vec3_muls( s * onebrcube , tmp);
                            vec3_add(CDip[a], tmp);
                            
                            //SDip[a] = vec3_add(
                            //                SDip[a],
                            //                vec3_sub(
                            //                    vec3_muls( s * onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Ahelix[a],u),u), Ahelix[a])),
                            //                    vec3_muls( c * onebrcube ,vec3_sub(vec3_muls(3.0*vec3_dot(Bhelix[a],u),u), Bhelix[a]))
                            //                )
                            //            );
                            vec3_cpy(tmp, u);
                            vec3_muls(3.0*vec3_dot(Ahelix[a],tmp),tmp);
                            vec3_sub(tmp, Ahelix[a]);
                            vec3_muls( s * onebrcube , tmp);
                            vec3_add(SDip[a], tmp);
                            
                            
                            vec3_cpy(tmp, u);
                            vec3_muls(3.0*vec3_dot(Bhelix[a],tmp),tmp);
                            vec3_sub(tmp, Bhelix[a]);
                            vec3_muls( c * onebrcube , tmp);
                            vec3_sub(SDip[a], tmp);
                            
                            
                        }
                        #pragma omp critical(lorentz)
                        {
                            // Lorentz
                            //CLor[a] = vec3_add(
                            //                CLor[a],
                            //                vec3_add(
                            //                    vec3_muls( c , Ahelix[a]),
                            //                    vec3_muls( s , Bhelix[a])
                            //                )
                            //            );
                            vec3_daxpy(c, Ahelix[a], CLor[a]);
                            vec3_daxpy(s, Bhelix[a], CLor[a]);

                            
                            //SLor[a] = vec3_add(
                            //                SLor[a],
                            //                vec3_sub(
                            //                    vec3_muls( s ,Ahelix[a]),
                            //                    vec3_muls( c ,Bhelix[a])
                            //                )
                            //            );
                            vec3_daxpy(s, Ahelix[a], SLor[a]);
                            vec3_daxpy(-1.* c, Bhelix[a], SLor[a]);
                        }
						// Contact
						if (n < cont_radius) {
                            #pragma omp critical(contact)
                            {
                                //vec3_cpy(tmp, Ahelix[a]);
                                vec3_set(tmp, 0.,0.,0.);
                                //vec3_muls( stagmom[a] * c , tmp);
                                
                                vec3_daxpy( stagmom[a] * c , Ahelix[a], tmp);
                                vec3_daxpy( stagmom[a] * s , Bhelix[a], tmp);
                                //printf("CCont %d to be added : %e %e %e\n", a, tmp->x, tmp->y, tmp->z);
                                pile_add_element(&CCont, pow(n,CONT_SCALING_POWER), tmp);
                                
                                
                                //vec3_cpy(tmp, Ahelix[a]);
                                vec3_set(tmp, 0.,0.,0.);
                                //vec3_muls( stagmom[a] * s , tmp);
                                vec3_daxpy( stagmom[a] * s , Ahelix[a], tmp);
                                vec3_daxpy( -1.*stagmom[a] * c , Bhelix[a], tmp);
                                //printf("SCont %d to be added : %e %e %e\n", a, tmp->x, tmp->y, tmp->z);
                                pile_add_element(&SCont, pow(n,CONT_SCALING_POWER), tmp);
                            }
                        }
#ifdef _DEBUG                      
                        printf("CDip %d is now : %e %e %e\n", a, CDip[a]->x, CDip[a]->y, CDip[a]->z);
                        printf("SDip %d is now : %e %e %e\n", a, SDip[a]->x, SDip[a]->y, SDip[a]->z);
#endif
                    }
                }
            }
        }
    }
}
    
    double angle=0;
    vec3 * BDip;
    vec3 * BLor;
    vec3 * BCont;

    // for contact field evaluation
    vec3 * CBCont; // = vec3_zero();
    vec3 * SBCont; // = vec3_zero();
    int NofM = 0; // Number of moments considered
    double SumOfWeights = 0;    
    
#pragma omp parallel sections private(angn,angle,BDip,BLor,BCont,i) firstprivate(CBCont,SBCont,NofM,SumOfWeights)
{
    // first portion, dipolar fields and Lorentz
    #pragma omp section
    {
        BDip = new_vec3_zero();
        BLor = new_vec3_zero();
        for (angn = 0; angn < in_nangles; ++angn)
        {
            angle = 2*M_PI*((float) angn / (float) in_nangles);
            
            //  === Dipolar Field ===
            vec3_set(BDip, 0., 0., 0.);
            // loop over atoms
            for (a = 0; a < in_natoms; ++a)
            {
                vec3_cpy(tmp, CDip[a]);
                vec3_muls(cos(angle) , tmp);
                
                vec3_daxpy(-1.*sin(angle) , SDip[a], tmp);
                vec3_daxpy(stagmom[a] , tmp, BDip);
                
                
                //BDip =  vec3_add(BDip,
                //                vec3_muls(
                //                    stagmom[a],
                //                    vec3_sub(
                //                        vec3_muls(cos(angle) , CDip[a]),
                //                        vec3_muls(sin(angle) , SDip[a])
                //                    )
                //                )
                //            );
            }
            
            vec3_muls(0.9274009, BDip); // to tesla units
            vec3_getp(BDip, &(out_field_dip[3*angn]));
            
            
            //  === Lorentz Field ===
            vec3_set(BLor, 0., 0., 0.);
            // loop over atoms
            for (a = 0; a < in_natoms; ++a)
            {
                //BLor =  vec3_add(BLor,
                //                vec3_muls(
                //                    stagmom[a],
                //                    vec3_sub(
                //                        vec3_muls(cos(angle) , CLor[a]),
                //                        vec3_muls(sin(angle) , SLor[a])
                //                    )
                //                )
                //            );
                
                vec3_cpy(tmp, CLor[a]);
                vec3_muls(cos(angle), tmp);
                vec3_daxpy(-1.0*sin(angle) , SLor[a], tmp);
                vec3_daxpy(stagmom[a] , tmp, BLor);
                
            }
            
            vec3_muls(0.33333333333*11.654064*(3./(4.*M_PI*pow(radius,3))),BLor);
            vec3_getp(BLor, &(out_field_lor[3*angn]));       
            
        }
        vec3_free(BDip);
        vec3_free(BLor);
    }


    // second portion, contact fields
    #pragma omp section
    {
        //  === Contact Field ===
        BCont = new_vec3_zero();
        CBCont = new_vec3_zero();
        SBCont = new_vec3_zero();
        for (i=0; i < nnn_for_cont; i++) {
            if ((CCont.ranks[i] >= 0.0) && (fabs(CCont.ranks[i] - SCont.ranks[i])<EPS)) {
                vec3_daxpy(1./CCont.ranks[i],CCont.elements[i], CBCont);
                vec3_daxpy(1./SCont.ranks[i],SCont.elements[i], SBCont);
                
                SumOfWeights += 1./CCont.ranks[i];
                NofM++;
            } else {
                printf("Something VERY odd ! ranks 1: %e ranks 2: %e \n", CCont.ranks[i] , SCont.ranks[i] );
            }
        }
        //printf("CBCont is now : %e %e %e\n", CBCont->x, CBCont->y, CBCont->z);
        //printf("SBCont is now : %e %e %e\n", SBCont->x, SBCont->y, SBCont->z);
        // (2 magnetic_constant/3)⋅1bohr_magneton   = ((2 ⋅ magnetic_constant) ∕ 3) ⋅ (1 ⋅ bohr_magneton)
        //   ≈ 7.769376E-27((g⋅m^3) ∕ (A⋅s^2))
        //   ≈ 7.769376 T⋅Å^3
        
        for (angn = 0; angn < in_nangles; ++angn) {
            
            angle = 2*M_PI*((float) angn / (float) in_nangles);
            vec3_set(BCont, 0., 0., 0.);
            if (NofM >0) {
                vec3_daxpy(cos(angle) , CBCont, BCont);
                vec3_daxpy(-1.*sin(angle) , SBCont, BCont);
                vec3_muls((1./SumOfWeights) * 7.769376, BCont);
            } // otherwise is zero anyway!
            //printf("BCont final : %e %e %e\n", BCont->x, BCont->y, BCont->z);
            vec3_getp(BCont, &(out_field_cont[3*angn+0]));  
        }
        vec3_free(BCont);
        vec3_free(CBCont);
        vec3_free(SBCont);
    }
} // end of omp parallel sections

    // free stuff used for contact field
    pile_free(&CCont);
    pile_free(&SCont);
    free(stagmom);
    for (a = 0; a < in_natoms; ++a)
    {
        vec3_free(Ahelix[a]);
        vec3_free(Bhelix[a]);
        vec3_free(CDip[a]);
        vec3_free(SDip[a]);
        vec3_free(CLor[a]);
        vec3_free(SLor[a]);
    }
    free(Ahelix);free(Bhelix);
    free(CDip);free(SDip);
    free(CLor);free(SLor);
    
    mat3_free(inv_sc_lat);
    vec3_free(atmpos);
    vec3_free(r);

    vec3_free(K);
    vec3_free(muonpos);
    vec3_free(tmp);
    
    mat3_free(sc_lat);
    
}



/**
 * @file fastincommsum.c
 * @author Pietro Bonfa
 * @date 9 Sep 2016
 * @brief Dipolar field calculator.
 *     
 */

#define _USE_MATH_DEFINES
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "lattice.h"
#include "pile.h"
#include "config.h"

#ifndef M_PI
#    define M_PI 3.14159265358979323846
#endif

#ifdef _OPENMP
#include <omp.h>
#endif 
extern "C" {

/**
 * This function calculates the dipolar field for helical structures
 * 
 * @param in_positions positions of the magnetic atoms in fractional 
 *         coordinates. Each position is specified by the three
 *         coordinates and the 1D array must be 3*in_natoms long.
 * @param in_fc Fourier components. For each atom in in_positions 6 numbers must be specified.
 *              The standard input is Re(FC_x) Im(FC_x) Re(FC_y) Im(FC_y) Re(FC_z) Im(FC_z)
 *              (the input format can be changed by defining the 
 *              _ALTERNATE_FC_INPUT at compile time, but this is highly discouraged).
 *              These values must be provided in the Cartesian coordinate system
 *              defined by in_cell.
 * @param in_K the propagation vector in reciprocal lattice units.
 * @param in_phi the phase for each of the atoms given in in_positions.
 * @param in_muonpos position of the muon in fractional coordinates
 * @param in_supercell extension of the supercell along the lattice vectors.
 * @param in_cell lattice cell. The three lattice vectors should be entered 
 *         with the following order: a_x, a_y, a_z, b_z, b_y, b_z, c_x, c_y, c_z.
 * @param radius Lorentz sphere radius
 * @param nnn_for_cont number of nearest neighboring atoms to be included
 *                      for the evaluation of the contact field.
 * @param cont_radius only atoms within this radius are eligible to contribute to
 *                      the contact field. This option is redundant but speeds
 *                      up the evaluation significantly
 * @param in_natoms: number of atoms in the lattice.
 * @param in_nangles: number of angles used to sample the field distribution 
 *                      generated by an incommensurate order
 * @param out_field_cont Contact filed in Cartesian coordinates defined by in_cell.
 * @param out_field_dip  Dipolar field in Cartesian coordinates defined by in_cell.
 * @param out_field_lor  Lorentz field in Cartesian coordinates defined by in_cell.
 */
void FastIncommSum(const double *in_positions, 
          const double *in_fc, const double *in_K, const double *in_phi,
          const double *in_muonpos, const int * in_supercell, const double *in_cell, 
          const double radius, const unsigned int nnn_for_cont, const double cont_radius, 
          unsigned int in_natoms, unsigned int in_nangles,
          double *out_field_cont, double *out_field_dip, double *out_field_lor) 
{

    unsigned int scx, scy, scz = 10; /*supercell sizes */
    unsigned int i,j,k; /* counters for supercells */
    
    Vec3 atmpos;
    Vec3 atomposCart;
    Vec3 muonpos;
    Vec3 muonposCart;
    
    Vec3 r;
    Vec3 u;   /* unit vector */
    
    Mat3 lattice;
    Mat3 recLattice;
    Mat3 sc_lat;
    
    double n;
    double c,s; /*cosine and sine of K.R */
    double onebrcube; /* 1/r^3 */
    
    double  phi ;
    
    /* tmp value for speed and clearness */
    Vec3 crysvec;
    T KdotR;
    
    VecX stagmom(in_natoms);                    /* this is m_0 */
    MatX refatmpos(3, in_natoms);             /* reference atom used to produce C and S     */
    MatX refatomposCart(3, in_natoms);             /* reference atom used to produce C and S     */
    MatX Ahelix(3, in_natoms ) ;
    MatX Bhelix(3, in_natoms );/* two unit vectors describing the helix in the m_0 (cos(phi).a +/- sin(phi).b) */
    MatX SDip(3, in_natoms );
    MatX CDip(3, in_natoms ); /* sums of contribution providing cosine and sine prefactors */
    MatX SLor(3, in_natoms );  
    MatX CLor(3, in_natoms );/* sums of contribution providing cosine and sine prefactors */
    
    pile CCont, SCont;
    
    Vec3 K, KCart;
    

    unsigned int a, angn;     /* counter for atoms */
    Vec3 aux;
    double angle = 0;
    Vec3 BDip;
    Vec3 BLor;
    Vec3 BCont;

    /* for contact field evaluation */
    Vec3 CBCont = Vec3::Zero();
    Vec3 SBCont = Vec3::Zero();
    int NofM = 0; /* Number of moments considered */
    double SumOfWeights = 0;
    int l;
    /* initialize variables */

    
    pile_init(CCont, nnn_for_cont);
    pile_init(SCont, nnn_for_cont);

    Ahelix.setZero(3, in_natoms);
    Bhelix.setZero(3, in_natoms);
    CDip.setZero(3, in_natoms);
    SDip.setZero(3, in_natoms);
    CLor.setZero(3, in_natoms);
    SLor.setZero(3, in_natoms);

    
    /* define dupercell size */
    scx = in_supercell[0];
    scy = in_supercell[1];
    scz = in_supercell[2];

#ifdef _DEBUG    
    printf("I use: %i %i %i\n",scx, scy, scz);    
    printf("Size is: %i\n",size);
#endif 
    lattice.col(0) << in_cell[0], in_cell[1], in_cell[2];
    lattice.col(1) << in_cell[3], in_cell[4], in_cell[5];
    lattice.col(2) << in_cell[6], in_cell[7], in_cell[8];
 
    recips(lattice, recLattice);
 
#ifdef _DEBUG      
    for (i=0;i<3;i++)
        printf("Cell is: %i %e %e %e\n",i,in_cell[i*3],in_cell[i*3+1],in_cell[i*3+2]);
        
    /*printf("a %e %e %e\n", sc_lat.a.x, sc_lat.a.y, sc_lat.a.z); */
#endif     
    
    K.x() = in_K[0]; K.y() = in_K[1]; K.z() = in_K[2];
    // go to reciprocal cartesia coordinates.
    Crys2Cart(recLattice, K, KCart, false);

#ifdef _DEBUG     
    std::cout << K.transpose() << std::endl;
    printf("Radius is: %e\n",radius);
#endif


    aux << (double) scx, (double) scy, (double) scz;
    sc_lat = lattice * aux.asDiagonal();
    
    
    /* muon position in reduced coordinates */
    muonpos.x() =  (in_muonpos[0] + (scx/2) ) / (float) scx;
    muonpos.y() =  (in_muonpos[1] + (scy/2) ) / (float) scy;
    muonpos.z() =  (in_muonpos[2] + (scz/2) ) / (float) scz;
    
    

#ifdef _DEBUG
    std::cout << "Muon pos (frac): " << muonpos.transpose() << std::endl;
#endif
    
    Crys2Cart(sc_lat, muonpos, muonposCart, false);

#ifdef _DEBUG
    std::cout << "Muon pos (cart): " << muonposCart.transpose() << std::endl;
#endif



    for (a = 0; a < in_natoms; ++a)
    {
        /* reference atom in reduced coordinates */
        /*   the first atom is chosen as reference */
        refatmpos.col(a).x() =  (in_positions[3*a+0] + (scx/2) ) / (T) scx;
        refatmpos.col(a).y() =  (in_positions[3*a+1] + (scy/2) ) / (T) scy;
        refatmpos.col(a).z() =  (in_positions[3*a+2] + (scz/2) ) / (T) scz;



        
        
        /* now take care of magntism */


        aux.x() = in_fc[6*a]; 
        aux.y() = in_fc[6*a+2]; 
        aux.z() = in_fc[6*a+4];

        stagmom(a) = aux.norm();
        Ahelix.col(a) = aux.normalized();

        
        /* now B */
        aux.x() = in_fc[6*a+1]; 
        aux.y() = in_fc[6*a+3]; 
        aux.z() = in_fc[6*a+5];

        /* check if they are the same */
        if (fabs(stagmom(a) - aux.norm())>EPS)
        {
            printf("ERROR!!! Staggered moment is different in real and imag parts of atom %u\n Use another routine!\n",a);
        }
        Bhelix.col(a) =  aux.normalized();

        if (fabs(Ahelix.col(a).dot(Bhelix.col(a))) > EPS)
        {
            printf("ERROR!!! Real and imaginary part of atom %u are not orthogonal by %e!\n",a,Ahelix.col(a).dot(Bhelix.col(a)));
        }

#ifdef _DEBUG
        printf("Unit vector a (cart): %e %e %e\n",Ahelix[a].x,Ahelix[a].y,Ahelix[a].z);
        printf("Unit vector b (cart): %e %e %e\n",Bhelix[a].x,Bhelix[a].y,Bhelix[a].z);
        printf("Stag mom: %e\n", stagmom[a]);
#endif        
        
        if (fabs(in_phi[a]) > EPS)
        {
            printf("WARNING!!! Phi not completely tested! Double check your results.\n");
        }
        
    }
    Crys2Cart(sc_lat, refatmpos, refatomposCart, false);

/* parallel execution starts here */
/* the shared variables are listed just to remember about data races! */
/* other variable shaed by default: refatmpos,atmpos,phi,Ahelix,Bhelix */
//pragma omp parallel shared(SDip,CDip,SLor,CLor,SCont,CCont,scx,scy,scz,in_positions) 
{
//pragma omp for collapse(3) private(i,j,k,a,r,n,c,s,u,crysvec,onebrcube,atmpos)
    for (i = 0; i < scx; ++i)
    {
        for (j = 0; j < scy; ++j)
        {
            for (k = 0; k < scz; ++k)
            {
                /* loop over atoms */
                for (a = 0; a < in_natoms; ++a)
                {
                    
                    /* atom position in reduced coordinates */
                    atmpos.x() = ( in_positions[3*a] + (float) i) / (float) scx;
                    atmpos.y() = ( in_positions[3*a+1] + (float) j) / (float) scy;
                    atmpos.z() = ( in_positions[3*a+2] + (float) k) / (float) scz;
                    
                    
                    
                    /* go to cartesian coordinates (in Angstrom!) */
                    Crys2Cart(sc_lat, atmpos, atomposCart, false);
                    
                    /*printf("atompos: %e %e %e\n", atmpos.x, atmpos.y, atmpos.z); */
                    /* difference between atom pos and muon pos (cart coordinates) */
                    
                    r = atomposCart - muonposCart;
                    
                    n = r.norm();
                    if (n < radius)
                    {

                        phi = in_phi[a];
                        
                        /* unit vector */
                        u = r.normalized();
                        onebrcube = 1.0/pow(n,3);
                        
                        // (atomposCart - muonposCart)  - refatomposCart
                        aux = r - refatomposCart.col(a);
                        
                        KdotR =  KCart.dot(aux); // R \dot K (done in cartesian coordinates)
                        
                        /* */
                        c = cos (KdotR + 2.0*M_PI*phi ) ;
                        s = sin (KdotR + 2.0*M_PI*phi ) ;

                        /* sum all data */
                        //pragma omp critical(dipolar)
                        {
                            /* Dipolar */
                            CDip.col(a) += c * onebrcube * (u*3.0*Ahelix.col(a).dot(u) - Ahelix.col(a) ) 
                                         + s * onebrcube * (u*3.0*Bhelix.col(a).dot(u) - Bhelix.col(a) );

                            SDip.col(a) += s * onebrcube * (u*3.0*Ahelix.col(a).dot(u) - Ahelix.col(a) ) 
                                         - c * onebrcube * (u*3.0*Bhelix.col(a).dot(u) - Bhelix.col(a) );

                        }
                        //pragma omp critical(lorentz)
                        {
                            /* Lorentz */
                            CLor.col(a) += c * Ahelix.col(a) + s*Bhelix.col(a);
                            SLor.col(a) += s * Ahelix.col(a) - c*Bhelix.col(a);

                        }
                        /* Contact */
                        if (n < cont_radius) {
                            //pragma omp critical(contact)
                            {
                                aux = stagmom(a) * (c * Ahelix.col(a) + s * Bhelix.col(a));
                                pile_add_element(CCont, pow(n,CONT_SCALING_POWER), aux);
                                
                                aux = stagmom(a) * (s * Ahelix.col(a) - c * Bhelix.col(a));
                                pile_add_element(SCont, pow(n,CONT_SCALING_POWER), aux);
                                //std::cout << aux.transpose() << "|" << stagmom(a) << " " << c << " "<<s<<" " << Ahelix.col(a).transpose() << " " << Bhelix.col(a).transpose() << " " << std::endl;
                                //for (l=0; l < nnn_for_cont; l++) {
                                //    std::cout << "C: " << nnn_for_cont << " " << l << " " << CCont.elements[i].transpose() << std::endl;
                                //    std::cout << "S: " << nnn_for_cont << " " << l << " "  << SCont.elements[i].transpose() << std::endl;
                                //}
                                //std::cout << "---" << std::endl;
                            }
                        }
                    }                    
                }
            }
        }
    }
}
    
    angle=0;
    /* for contact field evaluation */
    CBCont = Vec3::Zero();
    SBCont = Vec3::Zero();
    NofM = 0; /* Number of moments considered */
    SumOfWeights = 0;    
    
// pragma omp parallel sections private(angn,angle,BDip,BLor,BCont,i) firstprivate(CBCont,SBCont,NofM,SumOfWeights)
{
    /* first portion, dipolar fields and Lorentz */
    // pragma omp section
    {
        for (angn = 0; angn < in_nangles; ++angn)
        {
            angle = 2*M_PI*((float) angn / (float) in_nangles);
            
            /*  === Dipolar Field === */
            BDip = Vec3::Zero();
            /* loop over atoms */
            for (a = 0; a < in_natoms; ++a)
            {
                BDip +=  stagmom(a) * (cos(angle) * CDip.col(a) - sin(angle) * SDip.col(a));
            }
            
            BDip = 0.9274009 * BDip; /* to tesla units */
            out_field_dip[3*angn+0] = BDip.x();
            out_field_dip[3*angn+1] = BDip.y();
            out_field_dip[3*angn+2] = BDip.z();        
            
            
            /*  === Lorentz Field === */
            BLor = Vec3::Zero();
            /* loop over atoms */
            for (a = 0; a < in_natoms; ++a)
            {
                BLor +=  stagmom(a) * (cos(angle) * CLor.col(a) - sin(angle) * SLor.col(a));
            }
            
            BLor = 0.33333333333*11.654064*(3./(4.*M_PI*pow(radius,3))) * BLor;
            out_field_lor[3*angn+0] = BLor.x();
            out_field_lor[3*angn+1] = BLor.y();
            out_field_lor[3*angn+2] = BLor.z();        
            
        }
    }


    /* second portion, contact fields */
    //pragma omp section
    {
        /*  === Contact Field === */
        
        for (i=0; i < nnn_for_cont; i++) {
            if ((CCont.ranks(i) >= 0.0) && (fabs(CCont.ranks(i) - SCont.ranks(i))<EPS)) {
                CBCont += (1./CCont.ranks(i)) * CCont.elements.col(i);
                SBCont += (1./SCont.ranks(i)) * SCont.elements.col(i);
                SumOfWeights += 1./CCont.ranks(i);
                NofM++;
            } else {
                printf("Something VERY odd ! ranks 1: %e ranks 2: %e \n", CCont.ranks(i) , SCont.ranks(i) );
            }
        }
            
        /* (2 magnetic_constant/3)⋅1bohr_magneton   = ((2 ⋅ magnetic_constant) ∕ 3) ⋅ (1 ⋅ bohr_magneton) */
        /*   ≈ 7.769376E-27((g⋅m^3) ∕ (A⋅s^2)) */
        /*   ≈ 7.769376 T⋅Å^3 */
        
        BCont = Vec3::Zero();
        for (angn = 0; angn < in_nangles; ++angn) {
            
            angle = 2*M_PI*((T) angn / (T) in_nangles);
            
            if (NofM >0) {
                BCont = (1./SumOfWeights) * 7.769376 * (cos(angle) * CBCont - sin(angle) * SBCont);
            } /* otherwise is zero anyway! */
            
            out_field_cont[3*angn+0] = BCont.x();
            out_field_cont[3*angn+1] = BCont.y();
            out_field_cont[3*angn+2] = BCont.z();        
        }
    }
} /* end of omp parallel sections */

}

}

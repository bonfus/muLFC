/**
 * @file fastincommsum.c
 * @author Pietro Bonfa
 * @date 9 Sep 2016
 * @brief Dipolar field calculator.
 *     
 */

#define _USE_MATH_DEFINES
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "dipolesum.h"
#include "lattice.h"
#include "parsers.h"
#include "pile.h"
#include "config.h"

#ifndef M_PI
#    define M_PI 3.14159265358979323846
#endif

#ifdef _OPENMP
#include <omp.h>
#endif 
extern "C" {

/**
 * This function calculates the dipolar field for helical structures
 * 
 * @param in_positions positions of the magnetic atoms in fractional 
 *         coordinates. Each position is specified by the three
 *         coordinates and the 1D array must be 3*in_natoms long.
 * @param in_fc Fourier components. For each atom in in_positions 6 numbers must be specified.
 *              The standard input is Re(FC_x) Im(FC_x) Re(FC_y) Im(FC_y) Re(FC_z) Im(FC_z)
 *              (the input format can be changed by defining the 
 *              _ALTERNATE_FC_INPUT at compile time, but this is highly discouraged).
 *              These values must be provided in the Cartesian coordinate system
 *              defined by in_cell.
 * @param in_K the propagation vector in reciprocal lattice units.
 * @param in_phi the phase for each of the atoms given in in_positions.
 * @param in_muonpos position of the muon in fractional coordinates
 * @param in_supercell extension of the supercell along the lattice vectors.
 * @param in_cell lattice cell. The three lattice vectors should be entered 
 *         with the following order: a_x, a_y, a_z, b_z, b_y, b_z, c_x, c_y, c_z.
 * @param radius Lorentz sphere radius
 * @param nnn_for_cont number of nearest neighboring atoms to be included
 *                      for the evaluation of the contact field.
 * @param cont_radius only atoms within this radius are eligible to contribute to
 *                      the contact field. This option is redundant but speeds
 *                      up the evaluation significantly
 * @param in_natoms: number of atoms in the lattice.
 * @param in_nmuonpos: number of muon positions.
 * @param in_nangles: number of angles used to sample the field distribution 
 *                      generated by an incommensurate order
 * @param out_field_cont Contact filed in Cartesian coordinates defined by in_cell.
 * @param out_field_dip  Dipolar field in Cartesian coordinates defined by in_cell.
 * @param out_field_lor  Lorentz field in Cartesian coordinates defined by in_cell.
 */
void FastIncommSum(const double *in_positions, 
          const double *in_fc, const double *in_K, const double *in_phi,
          const double *in_muonpos, const int * in_supercell, const double *in_cell, 
          const double radius, const unsigned int nnn_for_cont, const double cont_radius, 
          const unsigned int in_natoms, const unsigned int in_nmuonpos, 
          const unsigned int in_nangles,
          double *out_field_cont, double *out_field_dip, double *out_field_lor) 
{

    unsigned int scx, scy, scz = 10; /*supercell sizes */
    unsigned int i,j,k; /* counters for supercells */
    
    MatX  atomicPos(3,in_natoms), MagAtomicPos(3,in_natoms);
    CMatX FC(3,in_natoms);
    VecX  phi(in_natoms);
    Vec3 muonpos;
    
    MatX BLor(3, in_nangles);
    MatX BCont(3, in_nangles);
    MatX BDip(3, in_nangles);
    
    Mat3 lattice;
    Vec3 K;
    
    int mag_atoms;
    unsigned int a, angn, mu;     /* counters */
    
    /* define dupercell size */
    scx = in_supercell[0];
    scy = in_supercell[1];
    scz = in_supercell[2];

    /* lattice vectors, in Angstrom units */
    lattice.col(0) << in_cell[0], in_cell[1], in_cell[2];
    lattice.col(1) << in_cell[3], in_cell[4], in_cell[5];
    lattice.col(2) << in_cell[6], in_cell[7], in_cell[8];
   
    /* propagation vector in fractional (reciprocal) coordinates */
    K.x() = in_K[0]; K.y() = in_K[1]; K.z() = in_K[2];
    
    /* Filter out non magnetic atoms, according to EPS value in config.h */
    mag_atoms = ParseAndFilterMagneticAtoms(in_positions, in_fc, in_phi, in_natoms, 
                                  atomicPos, MagAtomicPos, FC, phi);
    if (mag_atoms > 0 ) {
        phi.conservativeResize(mag_atoms);
        FC.conservativeResize(3, mag_atoms);
        MagAtomicPos.conservativeResize(3, mag_atoms);        
    }
    /* End of atom filtering */

    for (mu = 0; mu < in_nmuonpos; mu++)
    {

        /* muon position in fractional coordinates */
        muonpos.x() = in_muonpos[3*mu + 0];
        muonpos.y() = in_muonpos[3*mu + 1];
        muonpos.z() = in_muonpos[3*mu + 2];

        BLor.setZero(); BCont.setZero(); BDip.setZero();
        FastIncom(MagAtomicPos, FC, K, phi, muonpos, scx, scy, scz,
                    lattice, radius, nnn_for_cont, cont_radius, in_nangles,
                    BCont, BDip, BLor);
    
        a = 3*mu*in_nangles;
        for (angn = 0; angn < in_nangles; ++angn) {
            out_field_dip[a +0] = BDip.col(angn).x();
            out_field_dip[a +1] = BDip.col(angn).y();
            out_field_dip[a +2] = BDip.col(angn).z();        
    
            out_field_lor[a +0] = BLor.col(angn).x();
            out_field_lor[a +1] = BLor.col(angn).y();
            out_field_lor[a +2] = BLor.col(angn).z();        
    
            out_field_cont[a +0] = BCont.col(angn).x();
            out_field_cont[a +1] = BCont.col(angn).y();
            out_field_cont[a +2] = BCont.col(angn).z(); 
            a = a + 3;       
        }
    }
}

}





//    for (a = 0; a < MagAtomicPos.cols(); ++a)
//    {
//        /* reference atom in reduced coordinates */
//        /*   the first atom is chosen as reference */
//        refatmpos.col(a).x() =  (MagAtomicPos.col(a).x() + (scx/2) ) / (T) scx;
//        refatmpos.col(a).y() =  (MagAtomicPos.col(a).y() + (scy/2) ) / (T) scy;
//        refatmpos.col(a).z() =  (MagAtomicPos.col(a).z() + (scz/2) ) / (T) scz;
//
//
//
//        
//        
//        /* now take care of magntism */
//
//
//        //aux.x() = in_fc[6*a]; 
//        //aux.y() = in_fc[6*a+2]; 
//        //aux.z() = in_fc[6*a+4];
//
//        stagmom(a) = FC.col(a).real().norm();
//        Ahelix.col(a) = FC.col(a).real().normalized();
//
//        
//        /* now B */
//        //aux.x() = in_fc[6*a+1]; 
//        //aux.y() = in_fc[6*a+3]; 
//        //aux.z() = in_fc[6*a+5];
//
//        /* check if they are the same */
//        if (fabs(stagmom(a) - FC.col(a).imag().norm())>EPS)
//        {
//            printf("ERROR!!! Staggered moment is different in real and imag parts of atom %u\n Use another routine!\n",a);
//        }
//        Bhelix.col(a) =  FC.col(a).imag().normalized();
//
//        if (fabs(Ahelix.col(a).dot(Bhelix.col(a))) > EPS)
//        {
//            printf("ERROR!!! Real and imaginary part of atom %u are not orthogonal by %e!\n",a,Ahelix.col(a).dot(Bhelix.col(a)));
//        }
//   
//        
//        if (fabs(phi(a)) > EPS)
//        {
//            printf("WARNING!!! Phi not completely tested! Double check your results.\n");
//        }
//        
//    }
//    Crys2Cart(sc_lat, refatmpos, refatomposCart, false);
//
///* parallel execution starts here */
///* the shared variables are listed just to remember about data races! */
///* other variable shaed by default: refatmpos,atmpos,phi,Ahelix,Bhelix */
////pragma omp parallel shared(SDip,CDip,SLor,CLor,SCont,CCont,scx,scy,scz,in_positions) 
//{
////pragma omp for collapse(3) private(i,j,k,a,r,n,c,s,u,crysvec,onebrcube,atmpos)
//    for (i = 0; i < scx; ++i)
//    {
//        for (j = 0; j < scy; ++j)
//        {
//            for (k = 0; k < scz; ++k)
//            {
//                /* loop over atoms */
//                for (a = 0; a < mag_atoms; ++a)
//                {
//                    
//                    /* atom position in reduced coordinates */
//                    atmpos.x() = ( MagAtomicPos.col(a).x() + (float) i) / (float) scx;
//                    atmpos.y() = ( MagAtomicPos.col(a).y() + (float) j) / (float) scy;
//                    atmpos.z() = ( MagAtomicPos.col(a).z() + (float) k) / (float) scz;
//                    
//                    
//                    
//                    /* go to cartesian coordinates (in Angstrom!) */
//                    Crys2Cart(sc_lat, atmpos, atomposCart, false);
//                    
//                    /*printf("atompos: %e %e %e\n", atmpos.x, atmpos.y, atmpos.z); */
//                    /* difference between atom pos and muon pos (cart coordinates) */
//                    
//                    r = atomposCart - muonposCart;
//                    
//                    n = r.norm();
//                    if (n < radius)
//                    {
//                        
//                        /* unit vector */
//                        u = r.normalized();
//                        onebrcube = 1.0/pow(n,3);
//                        
//                        // (atomposCart - muonposCart)  - refatomposCart
//                        aux = r - refatomposCart.col(a);
//                        
//                        KdotR =  KCart.dot(aux); // R \dot K (done in cartesian coordinates)
//                        
//                        /* */
//                        c = cos (KdotR + 2.0*M_PI*phi(a) ) ;
//                        s = sin (KdotR + 2.0*M_PI*phi(a) ) ;
//
//                        /* sum all data */
//                        //pragma omp critical(dipolar)
//                        {
//                            /* Dipolar */
//                            CDip.col(a) += c * onebrcube * (u*3.0*Ahelix.col(a).dot(u) - Ahelix.col(a) ) 
//                                         + s * onebrcube * (u*3.0*Bhelix.col(a).dot(u) - Bhelix.col(a) );
//
//                            SDip.col(a) += s * onebrcube * (u*3.0*Ahelix.col(a).dot(u) - Ahelix.col(a) ) 
//                                         - c * onebrcube * (u*3.0*Bhelix.col(a).dot(u) - Bhelix.col(a) );
//
//                        }
//                        //pragma omp critical(lorentz)
//                        {
//                            /* Lorentz */
//                            CLor.col(a) += c * Ahelix.col(a) + s*Bhelix.col(a);
//                            SLor.col(a) += s * Ahelix.col(a) - c*Bhelix.col(a);
//
//                        }
//                        /* Contact */
//                        if (n < cont_radius) {
//                            //pragma omp critical(contact)
//                            {
//                                aux = stagmom(a) * (c * Ahelix.col(a) + s * Bhelix.col(a));
//                                pile_add_element(CCont, pow(n,CONT_SCALING_POWER), aux);
//                                
//                                aux = stagmom(a) * (s * Ahelix.col(a) - c * Bhelix.col(a));
//                                pile_add_element(SCont, pow(n,CONT_SCALING_POWER), aux);
//                                //std::cout << aux.transpose() << "|" << stagmom(a) << " " << c << " "<<s<<" " << Ahelix.col(a).transpose() << " " << Bhelix.col(a).transpose() << " " << std::endl;
//                                //for (l=0; l < nnn_for_cont; l++) {
//                                //    std::cout << "C: " << nnn_for_cont << " " << l << " " << CCont.elements[i].transpose() << std::endl;
//                                //    std::cout << "S: " << nnn_for_cont << " " << l << " "  << SCont.elements[i].transpose() << std::endl;
//                                //}
//                                //std::cout << "---" << std::endl;
//                            }
//                        }
//                    }                    
//                }
//            }
//        }
//    }
//}
//    
//    angle=0;
//    /* for contact field evaluation */
//    CBCont = Vec3::Zero();
//    SBCont = Vec3::Zero();
//    NofM = 0; /* Number of moments considered */
//    SumOfWeights = 0;    
//    
//// pragma omp parallel sections private(angn,angle,BDip,BLor,BCont,i) firstprivate(CBCont,SBCont,NofM,SumOfWeights)
//{
//    /* first portion, dipolar fields and Lorentz */
//    // pragma omp section
//    {
//        for (angn = 0; angn < in_nangles; ++angn)
//        {
//            angle = 2*M_PI*((float) angn / (float) in_nangles);
//            
//            /*  === Dipolar Field === */
//            BDip = Vec3::Zero();
//            /* loop over atoms */
//            for (a = 0; a < in_natoms; ++a)
//            {
//                BDip +=  stagmom(a) * (cos(angle) * CDip.col(a) - sin(angle) * SDip.col(a));
//            }
//            
//            BDip = 0.9274009 * BDip; /* to tesla units */
//            out_field_dip[3*angn+0] = BDip.x();
//            out_field_dip[3*angn+1] = BDip.y();
//            out_field_dip[3*angn+2] = BDip.z();        
//            
//            
//            /*  === Lorentz Field === */
//            BLor = Vec3::Zero();
//            /* loop over atoms */
//            for (a = 0; a < in_natoms; ++a)
//            {
//                BLor +=  stagmom(a) * (cos(angle) * CLor.col(a) - sin(angle) * SLor.col(a));
//            }
//            
//            BLor = 0.33333333333*11.654064*(3./(4.*M_PI*pow(radius,3))) * BLor;
//            out_field_lor[3*angn+0] = BLor.x();
//            out_field_lor[3*angn+1] = BLor.y();
//            out_field_lor[3*angn+2] = BLor.z();        
//            
//        }
//    }
//
//
//    /* second portion, contact fields */
//    //pragma omp section
//    {
//        /*  === Contact Field === */
//        
//        for (i=0; i < nnn_for_cont; i++) {
//            if ((CCont.ranks(i) >= 0.0) && (fabs(CCont.ranks(i) - SCont.ranks(i))<EPS)) {
//                CBCont += (1./CCont.ranks(i)) * CCont.elements.col(i);
//                SBCont += (1./SCont.ranks(i)) * SCont.elements.col(i);
//                SumOfWeights += 1./CCont.ranks(i);
//                NofM++;
//            } else {
//                printf("Something VERY odd ! ranks 1: %e ranks 2: %e \n", CCont.ranks(i) , SCont.ranks(i) );
//            }
//        }
//            
//        /* (2 magnetic_constant/3)⋅1bohr_magneton   = ((2 ⋅ magnetic_constant) ∕ 3) ⋅ (1 ⋅ bohr_magneton) */
//        /*   ≈ 7.769376E-27((g⋅m^3) ∕ (A⋅s^2)) */
//        /*   ≈ 7.769376 T⋅Å^3 */
//        
//        BCont = Vec3::Zero();
//        for (angn = 0; angn < in_nangles; ++angn) {
//            
//            angle = 2*M_PI*((T) angn / (T) in_nangles);
//            
//            if (NofM >0) {
//                BCont = (1./SumOfWeights) * 7.769376 * (cos(angle) * CBCont - sin(angle) * SBCont);
//            } /* otherwise is zero anyway! */
//            
//            out_field_cont[3*angn+0] = BCont.x();
//            out_field_cont[3*angn+1] = BCont.y();
//            out_field_cont[3*angn+2] = BCont.z();        
//        }
//    }
//} /* end of omp parallel sections */

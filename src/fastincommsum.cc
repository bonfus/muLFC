/**
 * @file fastincommsum.c
 * @author Pietro Bonfa
 * @date 9 Sep 2016
 * @brief Dipolar field calculator.
 *     
 */

#define _USE_MATH_DEFINES
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "dipolesum.h"
#include "lattice.h"
#include "parsers.h"
#include "pile.h"
#include "config.h"

#ifndef M_PI
#    define M_PI 3.14159265358979323846
#endif

#ifdef _OPENMP
#include <omp.h>
#endif 
extern "C" {

/**
 * This function calculates the dipolar field for helical structures
 * 
 * @param in_positions positions of the magnetic atoms in fractional 
 *         coordinates. Each position is specified by the three
 *         coordinates and the 1D array must be 3*in_natoms long.
 * @param in_fc Fourier components. For each atom in in_positions 6 numbers must be specified.
 *              The standard input is Re(FC_x) Im(FC_x) Re(FC_y) Im(FC_y) Re(FC_z) Im(FC_z)
 *              (the input format can be changed by defining the 
 *              _ALTERNATE_FC_INPUT at compile time, but this is highly discouraged).
 *              These values must be provided in the Cartesian coordinate system
 *              defined by in_cell.
 * @param in_K the propagation vector in reciprocal lattice units.
 * @param in_phi the phase for each of the atoms given in in_positions.
 * @param in_muonpos position of the muon in fractional coordinates
 * @param in_supercell extension of the supercell along the lattice vectors.
 * @param in_cell lattice cell. The three lattice vectors should be entered 
 *         with the following order: a_x, a_y, a_z, b_z, b_y, b_z, c_x, c_y, c_z.
 * @param radius Lorentz sphere radius
 * @param nnn_for_cont number of nearest neighboring atoms to be included
 *                      for the evaluation of the contact field.
 * @param cont_radius only atoms within this radius are eligible to contribute to
 *                      the contact field. This option is redundant but speeds
 *                      up the evaluation significantly
 * @param in_natoms: number of atoms in the lattice.
 * @param in_nmuonpos: number of muon positions.
 * @param in_nangles: number of angles used to sample the field distribution 
 *                      generated by an incommensurate order
 * @param out_field_cont Contact filed in Cartesian coordinates defined by in_cell.
 * @param out_field_dip  Dipolar field in Cartesian coordinates defined by in_cell.
 * @param out_field_lor  Lorentz field in Cartesian coordinates defined by in_cell.
 */
void FastIncommSum(const double *in_positions, 
          const double *in_fc, const double *in_K, const double *in_phi,
          const double *in_muonpos, const int * in_supercell, const double *in_cell, 
          const double radius, const unsigned int nnn_for_cont, const double cont_radius, 
          const unsigned int in_natoms, const unsigned int in_nmuonpos, 
          const unsigned int in_nangles,
          double *out_field_cont, double *out_field_dip, double *out_field_lor) 
{

    unsigned int scx, scy, scz = 10; /*supercell sizes */
    unsigned int i,j,k; /* counters for supercells */
    
    MatX  atomicPos(3,in_natoms), MagAtomicPos(3,in_natoms);
    CMatX FC(3,in_natoms);
    VecX  phi(in_natoms);
    Vec3 muonpos;
    
    MatX BLor(3, in_nangles);
    MatX BCont(3, in_nangles);
    MatX BDip(3, in_nangles);
    
    Mat3 lattice;
    Vec3 K;
    
    int mag_atoms;
    unsigned int a, angn, mu;     /* counters */
    
    /* define dupercell size */
    scx = in_supercell[0];
    scy = in_supercell[1];
    scz = in_supercell[2];

    /* lattice vectors, in Angstrom units */
    lattice.col(0) << in_cell[0], in_cell[1], in_cell[2];
    lattice.col(1) << in_cell[3], in_cell[4], in_cell[5];
    lattice.col(2) << in_cell[6], in_cell[7], in_cell[8];
   
    /* propagation vector in fractional (reciprocal) coordinates */
    K.x() = in_K[0]; K.y() = in_K[1]; K.z() = in_K[2];
    
    /* Filter out non magnetic atoms, according to EPS value in config.h */
    mag_atoms = ParseAndFilterMagneticAtoms(in_positions, in_fc, in_phi, in_natoms, 
                                  atomicPos, MagAtomicPos, FC, phi);
    if (mag_atoms > 0 ) {
        phi.conservativeResize(mag_atoms);
        FC.conservativeResize(3, mag_atoms);
        MagAtomicPos.conservativeResize(3, mag_atoms);        
    }
    /* End of atom filtering */

    for (mu = 0; mu < in_nmuonpos; mu++)
    {

        /* muon position in fractional coordinates */
        muonpos.x() = in_muonpos[3*mu + 0];
        muonpos.y() = in_muonpos[3*mu + 1];
        muonpos.z() = in_muonpos[3*mu + 2];

        BLor.setZero(); BCont.setZero(); BDip.setZero();
        FastIncom(MagAtomicPos, FC, K, phi, muonpos, scx, scy, scz,
                    lattice, radius, nnn_for_cont, cont_radius, in_nangles,
                    BCont, BDip, BLor);
    
        a = 3*mu*in_nangles;
        for (angn = 0; angn < in_nangles; ++angn) {
            out_field_dip[a +0] = BDip.col(angn).x();
            out_field_dip[a +1] = BDip.col(angn).y();
            out_field_dip[a +2] = BDip.col(angn).z();        
    
            out_field_lor[a +0] = BLor.col(angn).x();
            out_field_lor[a +1] = BLor.col(angn).y();
            out_field_lor[a +2] = BLor.col(angn).z();        
    
            out_field_cont[a +0] = BCont.col(angn).x();
            out_field_cont[a +1] = BCont.col(angn).y();
            out_field_cont[a +2] = BCont.col(angn).z(); 
            a = a + 3;       
        }
    }
}

} // extern C
